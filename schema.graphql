# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
	id: ID!
	name: String
	email: String
	password: PasswordState
	posts(
		where: PostWhereInput! = {}
		orderBy: [PostOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: PostWhereUniqueInput
	): [Post!]
	postsCount(where: PostWhereInput! = {}): Int
	createdAt: DateTime
}

type PasswordState {
	isSet: Boolean!
}

scalar DateTime @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input UserWhereUniqueInput {
	id: ID
	email: String
}

input UserWhereInput {
	AND: [UserWhereInput!]
	OR: [UserWhereInput!]
	NOT: [UserWhereInput!]
	id: IDFilter
	name: StringFilter
	email: StringFilter
	posts: PostManyRelationFilter
	createdAt: DateTimeNullableFilter
}

input IDFilter {
	equals: ID
	in: [ID!]
	notIn: [ID!]
	lt: ID
	lte: ID
	gt: ID
	gte: ID
	not: IDFilter
}

input StringFilter {
	equals: String
	in: [String!]
	notIn: [String!]
	lt: String
	lte: String
	gt: String
	gte: String
	contains: String
	startsWith: String
	endsWith: String
	mode: QueryMode
	not: NestedStringFilter
}

enum QueryMode {
	default
	insensitive
}

input NestedStringFilter {
	equals: String
	in: [String!]
	notIn: [String!]
	lt: String
	lte: String
	gt: String
	gte: String
	contains: String
	startsWith: String
	endsWith: String
	not: NestedStringFilter
}

input PostManyRelationFilter {
	every: PostWhereInput
	some: PostWhereInput
	none: PostWhereInput
}

input DateTimeNullableFilter {
	equals: DateTime
	in: [DateTime!]
	notIn: [DateTime!]
	lt: DateTime
	lte: DateTime
	gt: DateTime
	gte: DateTime
	not: DateTimeNullableFilter
}

input UserOrderByInput {
	id: OrderDirection
	name: OrderDirection
	email: OrderDirection
	createdAt: OrderDirection
}

enum OrderDirection {
	asc
	desc
}

input UserUpdateInput {
	name: String
	email: String
	password: String
	posts: PostRelateToManyForUpdateInput
	createdAt: DateTime
}

input PostRelateToManyForUpdateInput {
	disconnect: [PostWhereUniqueInput!]
	set: [PostWhereUniqueInput!]
	create: [PostCreateInput!]
	connect: [PostWhereUniqueInput!]
}

input UserUpdateArgs {
	where: UserWhereUniqueInput!
	data: UserUpdateInput!
}

input UserCreateInput {
	name: String
	email: String
	password: String
	posts: PostRelateToManyForCreateInput
	createdAt: DateTime
}

input PostRelateToManyForCreateInput {
	create: [PostCreateInput!]
	connect: [PostWhereUniqueInput!]
}

type Post {
	id: ID!
	title: String
	content: Post_content_Document
	author: User
	tags(
		where: TagWhereInput! = {}
		orderBy: [TagOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: TagWhereUniqueInput
	): [Tag!]
	tagsCount(where: TagWhereInput! = {}): Int
}

type Post_content_Document {
	document(hydrateRelationships: Boolean! = false): JSON!
}

input PostWhereUniqueInput {
	id: ID
}

input PostWhereInput {
	AND: [PostWhereInput!]
	OR: [PostWhereInput!]
	NOT: [PostWhereInput!]
	id: IDFilter
	title: StringFilter
	author: UserWhereInput
	tags: TagManyRelationFilter
}

input TagManyRelationFilter {
	every: TagWhereInput
	some: TagWhereInput
	none: TagWhereInput
}

input PostOrderByInput {
	id: OrderDirection
	title: OrderDirection
}

input PostUpdateInput {
	title: String
	content: JSON
	author: UserRelateToOneForUpdateInput
	tags: TagRelateToManyForUpdateInput
}

input UserRelateToOneForUpdateInput {
	create: UserCreateInput
	connect: UserWhereUniqueInput
	disconnect: Boolean
}

input TagRelateToManyForUpdateInput {
	disconnect: [TagWhereUniqueInput!]
	set: [TagWhereUniqueInput!]
	create: [TagCreateInput!]
	connect: [TagWhereUniqueInput!]
}

input PostUpdateArgs {
	where: PostWhereUniqueInput!
	data: PostUpdateInput!
}

input PostCreateInput {
	title: String
	content: JSON
	author: UserRelateToOneForCreateInput
	tags: TagRelateToManyForCreateInput
}

input UserRelateToOneForCreateInput {
	create: UserCreateInput
	connect: UserWhereUniqueInput
}

input TagRelateToManyForCreateInput {
	create: [TagCreateInput!]
	connect: [TagWhereUniqueInput!]
}

type Tag {
	id: ID!
	name: String
	posts(
		where: PostWhereInput! = {}
		orderBy: [PostOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: PostWhereUniqueInput
	): [Post!]
	postsCount(where: PostWhereInput! = {}): Int
}

input TagWhereUniqueInput {
	id: ID
}

input TagWhereInput {
	AND: [TagWhereInput!]
	OR: [TagWhereInput!]
	NOT: [TagWhereInput!]
	id: IDFilter
	name: StringFilter
	posts: PostManyRelationFilter
}

input TagOrderByInput {
	id: OrderDirection
	name: OrderDirection
}

input TagUpdateInput {
	name: String
	posts: PostRelateToManyForUpdateInput
}

input TagUpdateArgs {
	where: TagWhereUniqueInput!
	data: TagUpdateInput!
}

input TagCreateInput {
	name: String
	posts: PostRelateToManyForCreateInput
}

type Image {
	id: ID!
	image: CloudinaryImage_File
	alt: String
	category: String
}

type CloudinaryImage_File {
	id: ID
	filename: String
	originalFilename: String
	mimetype: String
	encoding: String
	publicUrl: String
	publicUrlTransformed(transformation: CloudinaryImageFormat): String
}

"""
Mirrors the formatting options [Cloudinary provides](https://cloudinary.com/documentation/image_transformation_reference).
All options are strings as they ultimately end up in a URL.
"""
input CloudinaryImageFormat {
	"""
	Rewrites the filename to be this pretty string. Do not include `/` or `.`
	"""
	prettyName: String
	width: String
	height: String
	crop: String
	aspect_ratio: String
	gravity: String
	zoom: String
	x: String
	y: String
	format: String
	fetch_format: String
	quality: String
	radius: String
	angle: String
	effect: String
	opacity: String
	border: String
	background: String
	overlay: String
	underlay: String
	default_image: String
	delay: String
	color: String
	color_space: String
	dpr: String
	page: String
	density: String
	flags: String
	transformation: String
}

input ImageWhereUniqueInput {
	id: ID
}

input ImageWhereInput {
	AND: [ImageWhereInput!]
	OR: [ImageWhereInput!]
	NOT: [ImageWhereInput!]
	id: IDFilter
	alt: StringFilter
	category: StringNullableFilter
}

input StringNullableFilter {
	equals: String
	in: [String!]
	notIn: [String!]
	lt: String
	lte: String
	gt: String
	gte: String
	contains: String
	startsWith: String
	endsWith: String
	mode: QueryMode
	not: StringNullableFilter
}

input ImageOrderByInput {
	id: OrderDirection
	alt: OrderDirection
	category: OrderDirection
}

input ImageUpdateInput {
	image: Upload
	alt: String
	category: String
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

input ImageUpdateArgs {
	where: ImageWhereUniqueInput!
	data: ImageUpdateInput!
}

input ImageCreateInput {
	image: Upload
	alt: String
	category: String
}

type Event {
	id: ID!
	title: String
	headerImage: Image
	date: CalendarDay
	from: String
	until: String
	pastEvent: Boolean
	location: String
	content: Event_content_Document
	timestamp: DateTime
}

scalar CalendarDay @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

type Event_content_Document {
	document(hydrateRelationships: Boolean! = false): JSON!
}

input EventWhereUniqueInput {
	id: ID
}

input EventWhereInput {
	AND: [EventWhereInput!]
	OR: [EventWhereInput!]
	NOT: [EventWhereInput!]
	id: IDFilter
	title: StringFilter
	headerImage: ImageWhereInput
	date: CalendarDayNullableFilter
	from: StringFilter
	until: StringFilter
	pastEvent: BooleanFilter
	location: StringFilter
	timestamp: DateTimeNullableFilter
}

input CalendarDayNullableFilter {
	equals: CalendarDay
	in: [CalendarDay!]
	notIn: [CalendarDay!]
	lt: CalendarDay
	lte: CalendarDay
	gt: CalendarDay
	gte: CalendarDay
	not: CalendarDayNullableFilter
}

input BooleanFilter {
	equals: Boolean
	not: BooleanFilter
}

input EventOrderByInput {
	id: OrderDirection
	title: OrderDirection
	date: OrderDirection
	from: OrderDirection
	until: OrderDirection
	pastEvent: OrderDirection
	location: OrderDirection
	timestamp: OrderDirection
}

input EventUpdateInput {
	title: String
	headerImage: ImageRelateToOneForUpdateInput
	date: CalendarDay
	from: String
	until: String
	pastEvent: Boolean
	location: String
	content: JSON
	timestamp: DateTime
}

input ImageRelateToOneForUpdateInput {
	create: ImageCreateInput
	connect: ImageWhereUniqueInput
	disconnect: Boolean
}

input EventUpdateArgs {
	where: EventWhereUniqueInput!
	data: EventUpdateInput!
}

input EventCreateInput {
	title: String
	headerImage: ImageRelateToOneForCreateInput
	date: CalendarDay
	from: String
	until: String
	pastEvent: Boolean
	location: String
	content: JSON
	timestamp: DateTime
}

input ImageRelateToOneForCreateInput {
	create: ImageCreateInput
	connect: ImageWhereUniqueInput
}

type Activist {
	id: ID!
	name: String
	url: String
	thumbnail: Image
	description: String
}

input ActivistWhereUniqueInput {
	id: ID
}

input ActivistWhereInput {
	AND: [ActivistWhereInput!]
	OR: [ActivistWhereInput!]
	NOT: [ActivistWhereInput!]
	id: IDFilter
	name: StringFilter
	url: StringFilter
	thumbnail: ImageWhereInput
	description: StringFilter
}

input ActivistOrderByInput {
	id: OrderDirection
	name: OrderDirection
	url: OrderDirection
	description: OrderDirection
}

input ActivistUpdateInput {
	name: String
	url: String
	thumbnail: ImageRelateToOneForUpdateInput
	description: String
}

input ActivistUpdateArgs {
	where: ActivistWhereUniqueInput!
	data: ActivistUpdateInput!
}

input ActivistCreateInput {
	name: String
	url: String
	thumbnail: ImageRelateToOneForCreateInput
	description: String
}

type Podcast {
	id: ID!
	name: String
	url: String
	thumbnail: Image
	description: String
}

input PodcastWhereUniqueInput {
	id: ID
}

input PodcastWhereInput {
	AND: [PodcastWhereInput!]
	OR: [PodcastWhereInput!]
	NOT: [PodcastWhereInput!]
	id: IDFilter
	name: StringFilter
	url: StringFilter
	thumbnail: ImageWhereInput
	description: StringFilter
}

input PodcastOrderByInput {
	id: OrderDirection
	name: OrderDirection
	url: OrderDirection
	description: OrderDirection
}

input PodcastUpdateInput {
	name: String
	url: String
	thumbnail: ImageRelateToOneForUpdateInput
	description: String
}

input PodcastUpdateArgs {
	where: PodcastWhereUniqueInput!
	data: PodcastUpdateInput!
}

input PodcastCreateInput {
	name: String
	url: String
	thumbnail: ImageRelateToOneForCreateInput
	description: String
}

type Video {
	id: ID!
	name: String
	thumbnail: Image
	url: String
	description: String
}

input VideoWhereUniqueInput {
	id: ID
}

input VideoWhereInput {
	AND: [VideoWhereInput!]
	OR: [VideoWhereInput!]
	NOT: [VideoWhereInput!]
	id: IDFilter
	name: StringFilter
	thumbnail: ImageWhereInput
	url: StringFilter
	description: StringFilter
}

input VideoOrderByInput {
	id: OrderDirection
	name: OrderDirection
	url: OrderDirection
	description: OrderDirection
}

input VideoUpdateInput {
	name: String
	thumbnail: ImageRelateToOneForUpdateInput
	url: String
	description: String
}

input VideoUpdateArgs {
	where: VideoWhereUniqueInput!
	data: VideoUpdateInput!
}

input VideoCreateInput {
	name: String
	thumbnail: ImageRelateToOneForCreateInput
	url: String
	description: String
}

type Book {
	id: ID!
	name: String
	author: String
	thumbnail: Image
	url: String
	description: String
}

input BookWhereUniqueInput {
	id: ID
	author: String
}

input BookWhereInput {
	AND: [BookWhereInput!]
	OR: [BookWhereInput!]
	NOT: [BookWhereInput!]
	id: IDFilter
	name: StringFilter
	author: StringFilter
	thumbnail: ImageWhereInput
	url: StringFilter
	description: StringFilter
}

input BookOrderByInput {
	id: OrderDirection
	name: OrderDirection
	author: OrderDirection
	url: OrderDirection
	description: OrderDirection
}

input BookUpdateInput {
	name: String
	author: String
	thumbnail: ImageRelateToOneForUpdateInput
	url: String
	description: String
}

input BookUpdateArgs {
	where: BookWhereUniqueInput!
	data: BookUpdateInput!
}

input BookCreateInput {
	name: String
	author: String
	thumbnail: ImageRelateToOneForCreateInput
	url: String
	description: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Mutation {
	createUser(data: UserCreateInput!): User
	createUsers(data: [UserCreateInput!]!): [User]
	updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
	updateUsers(data: [UserUpdateArgs!]!): [User]
	deleteUser(where: UserWhereUniqueInput!): User
	deleteUsers(where: [UserWhereUniqueInput!]!): [User]
	createPost(data: PostCreateInput!): Post
	createPosts(data: [PostCreateInput!]!): [Post]
	updatePost(where: PostWhereUniqueInput!, data: PostUpdateInput!): Post
	updatePosts(data: [PostUpdateArgs!]!): [Post]
	deletePost(where: PostWhereUniqueInput!): Post
	deletePosts(where: [PostWhereUniqueInput!]!): [Post]
	createTag(data: TagCreateInput!): Tag
	createTags(data: [TagCreateInput!]!): [Tag]
	updateTag(where: TagWhereUniqueInput!, data: TagUpdateInput!): Tag
	updateTags(data: [TagUpdateArgs!]!): [Tag]
	deleteTag(where: TagWhereUniqueInput!): Tag
	deleteTags(where: [TagWhereUniqueInput!]!): [Tag]
	createImage(data: ImageCreateInput!): Image
	createImages(data: [ImageCreateInput!]!): [Image]
	updateImage(where: ImageWhereUniqueInput!, data: ImageUpdateInput!): Image
	updateImages(data: [ImageUpdateArgs!]!): [Image]
	deleteImage(where: ImageWhereUniqueInput!): Image
	deleteImages(where: [ImageWhereUniqueInput!]!): [Image]
	createEvent(data: EventCreateInput!): Event
	createEvents(data: [EventCreateInput!]!): [Event]
	updateEvent(where: EventWhereUniqueInput!, data: EventUpdateInput!): Event
	updateEvents(data: [EventUpdateArgs!]!): [Event]
	deleteEvent(where: EventWhereUniqueInput!): Event
	deleteEvents(where: [EventWhereUniqueInput!]!): [Event]
	createActivist(data: ActivistCreateInput!): Activist
	createActivists(data: [ActivistCreateInput!]!): [Activist]
	updateActivist(where: ActivistWhereUniqueInput!, data: ActivistUpdateInput!): Activist
	updateActivists(data: [ActivistUpdateArgs!]!): [Activist]
	deleteActivist(where: ActivistWhereUniqueInput!): Activist
	deleteActivists(where: [ActivistWhereUniqueInput!]!): [Activist]
	createPodcast(data: PodcastCreateInput!): Podcast
	createPodcasts(data: [PodcastCreateInput!]!): [Podcast]
	updatePodcast(where: PodcastWhereUniqueInput!, data: PodcastUpdateInput!): Podcast
	updatePodcasts(data: [PodcastUpdateArgs!]!): [Podcast]
	deletePodcast(where: PodcastWhereUniqueInput!): Podcast
	deletePodcasts(where: [PodcastWhereUniqueInput!]!): [Podcast]
	createVideo(data: VideoCreateInput!): Video
	createVideos(data: [VideoCreateInput!]!): [Video]
	updateVideo(where: VideoWhereUniqueInput!, data: VideoUpdateInput!): Video
	updateVideos(data: [VideoUpdateArgs!]!): [Video]
	deleteVideo(where: VideoWhereUniqueInput!): Video
	deleteVideos(where: [VideoWhereUniqueInput!]!): [Video]
	createBook(data: BookCreateInput!): Book
	createBooks(data: [BookCreateInput!]!): [Book]
	updateBook(where: BookWhereUniqueInput!, data: BookUpdateInput!): Book
	updateBooks(data: [BookUpdateArgs!]!): [Book]
	deleteBook(where: BookWhereUniqueInput!): Book
	deleteBooks(where: [BookWhereUniqueInput!]!): [Book]
	endSession: Boolean!
	authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
	createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult =
	| UserAuthenticationWithPasswordSuccess
	| UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
	sessionToken: String!
	item: User!
}

type UserAuthenticationWithPasswordFailure {
	message: String!
}

input CreateInitialUserInput {
	name: String
	email: String
	password: String
}

type Query {
	users(
		where: UserWhereInput! = {}
		orderBy: [UserOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: UserWhereUniqueInput
	): [User!]
	user(where: UserWhereUniqueInput!): User
	usersCount(where: UserWhereInput! = {}): Int
	posts(
		where: PostWhereInput! = {}
		orderBy: [PostOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: PostWhereUniqueInput
	): [Post!]
	post(where: PostWhereUniqueInput!): Post
	postsCount(where: PostWhereInput! = {}): Int
	tags(
		where: TagWhereInput! = {}
		orderBy: [TagOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: TagWhereUniqueInput
	): [Tag!]
	tag(where: TagWhereUniqueInput!): Tag
	tagsCount(where: TagWhereInput! = {}): Int
	images(
		where: ImageWhereInput! = {}
		orderBy: [ImageOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: ImageWhereUniqueInput
	): [Image!]
	image(where: ImageWhereUniqueInput!): Image
	imagesCount(where: ImageWhereInput! = {}): Int
	events(
		where: EventWhereInput! = {}
		orderBy: [EventOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: EventWhereUniqueInput
	): [Event!]
	event(where: EventWhereUniqueInput!): Event
	eventsCount(where: EventWhereInput! = {}): Int
	activists(
		where: ActivistWhereInput! = {}
		orderBy: [ActivistOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: ActivistWhereUniqueInput
	): [Activist!]
	activist(where: ActivistWhereUniqueInput!): Activist
	activistsCount(where: ActivistWhereInput! = {}): Int
	podcasts(
		where: PodcastWhereInput! = {}
		orderBy: [PodcastOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: PodcastWhereUniqueInput
	): [Podcast!]
	podcast(where: PodcastWhereUniqueInput!): Podcast
	podcastsCount(where: PodcastWhereInput! = {}): Int
	videos(
		where: VideoWhereInput! = {}
		orderBy: [VideoOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: VideoWhereUniqueInput
	): [Video!]
	video(where: VideoWhereUniqueInput!): Video
	videosCount(where: VideoWhereInput! = {}): Int
	books(
		where: BookWhereInput! = {}
		orderBy: [BookOrderByInput!]! = []
		take: Int
		skip: Int! = 0
		cursor: BookWhereUniqueInput
	): [Book!]
	book(where: BookWhereUniqueInput!): Book
	booksCount(where: BookWhereInput! = {}): Int
	keystone: KeystoneMeta!
	authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
	adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
	lists: [KeystoneAdminUIListMeta!]!
	list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
	key: String!
	itemQueryName: String!
	listQueryName: String!
	hideCreate: Boolean!
	hideDelete: Boolean!
	path: String!
	label: String!
	singular: String!
	plural: String!
	description: String
	initialColumns: [String!]!
	pageSize: Int!
	labelField: String!
	fields: [KeystoneAdminUIFieldMeta!]!
	groups: [KeystoneAdminUIFieldGroupMeta!]!
	initialSort: KeystoneAdminUISort
	isHidden: Boolean!
	isSingleton: Boolean!
}

type KeystoneAdminUIFieldMeta {
	path: String!
	label: String!
	description: String
	isOrderable: Boolean!
	isFilterable: Boolean!
	isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
	fieldMeta: JSON
	viewsIndex: Int!
	customViewsIndex: Int
	createView: KeystoneAdminUIFieldMetaCreateView!
	listView: KeystoneAdminUIFieldMetaListView!
	itemView(id: ID): KeystoneAdminUIFieldMetaItemView
	search: QueryMode
}

enum KeystoneAdminUIFieldMetaIsNonNull {
	read
	create
	update
}

type KeystoneAdminUIFieldMetaCreateView {
	fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
	edit
	hidden
}

type KeystoneAdminUIFieldMetaListView {
	fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
	read
	hidden
}

type KeystoneAdminUIFieldMetaItemView {
	fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
	fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
	edit
	read
	hidden
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
	form
	sidebar
}

type KeystoneAdminUIFieldGroupMeta {
	label: String!
	description: String
	fields: [KeystoneAdminUIFieldMeta!]!
}

type KeystoneAdminUISort {
	field: String!
	direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
	ASC
	DESC
}
